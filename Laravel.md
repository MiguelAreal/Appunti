## Install

- Php -> `sudo apt install php`
- Nodejs -> `sudo apt install nodejs`
- Npm -> `sudo apt install npm`

#### Set Php version
```` bash
sudo apt install php8.0 #Install new version
sudo a2dismod php7.3 #Disable old version
sudo a2enmod php8.0 #Enable new version
sudo systemctl restart apache2
````
#### Install base libraries
```` bash
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install curl php-cli php-mbstring git unzip
````

#### Install Composer (globally)
[Offical Docs](https://getcomposer.org/download/)

Composer is a dependency management tool in PHP. For any PHP project, you need to use a library of code.
```` bash
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
php -r "if (hash_file('sha384', 'composer-setup.php') === '756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
php composer-setup.php
php -r "unlink('composer-setup.php');"
sudo mv composer.phar /usr/local/bin/composer #Make composer available globally
````
**Commands**
```` bash
composer update #Update composer
composer clear-cache #Clear cache
````

#### Create app
```` bash
composer create-project laravel/laravel example-app
````
**Specify version**
```` bash
composer create-project laravel/laravel=8 --prefer-dist example-app
````
#### Start server
```` bash
php artisan serve
````
**Specify socket**
```` bash
php artisan serve --host=127.0.0.1 --port=8002
````
## Folder Structure
**App**: Models, Controllers and Middleware
**Config**: Configuration files
**Database**: Migrations, Seeds
**Public**: Css, Js
**Resources**: Views
**Vendor**: Installation files

## Database
The .env file contains all the private configuration data and is listed as gitignore so it is not made public by synchronizing it with Git. It's important to put all configuration data in that file and no other files.

## LAMP
LAMP (Linux, Apache, MySQL, PHP/Perl/Python) is an acronym denoting one of the most common solution stacks for many of the web's most popular applications. However, LAMP now refers to a generic software stack model and its components are largely interchangeable.

## CSRF
A CSRF token is a unique, secret, unpredictable value that is generated by the server-side application and transmitted to the client in such a way that it is included in a subsequent HTTP request made by the client. When the later request is made, the server-side application validates that the request includes the expected token and rejects the request if the token is missing or invalid. 

## MVC
All SQL statements can be generated and executed in only one place and the data  validation and manipulation can be applied in one place: the model. The controller will handle the request/response lifecycle, taking the input from the user interface and updating model accordingly. When the controller gets the green signal from the mode

## Controller
Creare controller semplice:
````bash
php artisan make:controller nome
````
Creare controller CRUD:
````bash
php artisan make:controller --resource nome
````
Richiamre controller nelle route:
````php
Route::get('/page', '\App\Http\Controllers\ControllerName@function');
````
Richiamre controller nelle route passando parametri:
````php
Route::get('/page/{param}', '\App\Http\Controllers\ControllerName@function');
````

## Routes
The web.php file in the routes directory is important. It takes the requests from you, the user, and sends them to either a closure that gives a response, a view page that displays the response, or a controller that does the same thing; in some critical cases, the controller consults with the model and then is updated by the business logic.
For the web interface, the routes/web.php file defines the routes.

Listing all the routes: `php artisan route:list`

**Tipi di routes:**
````php
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);
````

**Redirect:**
````php
Route::redirect('/here', '/there');
````

**Route sempice che ritorna una view:**
````php
Route::get('/page', function () {
return view('helloworld');
});
````
Significa: Quando l'utente richiede la pagina "/", restituisci una view chiamata contact. In alternativa è possibile ritornare un Json o del semplice testo.
Raramente una route restituisce direttamente una view. Solitamente una route richiama una funzione del controller che elebora dei dati e restituisce una view.

**Route che ritorna solo una view (shortcut):**
````php
Route::view('/welcome', 'welcome');
````

**Route semplice con parametro:**
````php
Route::get('/page/{param}', function ($param) {
	echo $param;
});
````

**Route semplice con parametri:**
````php
Route::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) {
    //
});
````

**Route semplice con parametro opzionale:**
````php
Route::get('/user/{name?}', function ($name = null) {
    return $name;
});
````

**Route semplice con parametro opzionale e con default value:**
````php
Route::get('/user/{name?}', function ($name = 'John') {
    return $name;
});
````


**Route semplice con parametri e validazione:**
````php
Route::get('/page/{param}', function ($param) {
	echo $param;
})->where('param', '[A-z]+');
````
Si inserisce la condizione where seguita dal nome del paramtero e da una regex
Sono presenti condizioni di controllo predefinite come:
...`->whereAlpha('param');` -> Accetta solo lettere alfabeto
...`->whereAlphaNumeric('param');` -> Accetta solo lettere alfabeto e numeri
...`->whereNumber('param');` -> Accetta solo numeri


**Route naming: **

Per facilitare l'uso di link tra pageine del sito, é bene rinominare le route. In questo modo anche se si chiama l'url di una route, sarà comunque possibile accedervi attraverso il nome senza dover aggiornare tutti i link.

Rinominare route:
````php
Route::get('/home', [User::class, 'home'])->name('home');
````
Usare route attraverso il nome:
````html
<a href="{{route('home')}}">Link</a>
````
````php
Route::get('/contact/page/page/page',array('as'\=>'nome',function () {
return view('contact');
}));
````

**Routing sottodominio**
````php
Route::domain('{account}.example.com')->group(function () {
    Route::get('user/{id}', function ($account, $id) {
        //
    });
});
````
In order to ensure your subdomain routes are reachable, you should register subdomain routes before registering root domain routes. This will prevent root domain routes from overwriting subdomain routes which have the same URI path.

**Fallback Routes**
Permete di impostare una route nel caso una richiesta non combaci con nessun'altra route (es 404). Nel file web.php deve essere l'ultima route impostata (caso finale).
````php
Route::fallback(function () {
    //
});
````

**Current Route**
````php
use Illuminate\Support\Facades\Route;

$route = Route::current(); // Illuminate\Routing\Route
$name = Route::currentRouteName(); // string
$action = Route::currentRouteAction(); // string
});
````

## Views
I file di views terminano in .blade.php (non serve specificarlo quando si richiama la view).
Sarebbe possibile includere anche solo file .php o .html ma l'uso delle funzionalità messe a disposizione da blade è fortemente consigliato.

Link tra views
Basta linkare alla view voluta senza necessità di includere l'indirizzo completo
Es:
````html
<a href="/page1"> Pagina 1 </a>
````

### Blade
È un template engine. Quando viene richiamato, effettua una compilazione dalla sintassi blade ad un normale file php.
I file compilati si trovano in storage->framework->views.

#### Templating
Inserire contenuti in un certo punto: `@yield('content')`
Esempio layout:
````html
<!doctype html>

<title>Titolo</title>
<link rel="stylesheet" href="/css.css">

<body>
	@yield('content')
</body>

````

Estendere una vista per inserirci dentro dei contenuti: `@extends('layout')`.
Una volta esteso un file, tramite `@section` si crea una sezione che andà a prendere il posto di `@yield` nel file esteso.

Esempio vista:
````html
@extends('layout')

@section('content')
	<h1> Paragarfo 1 </h1>
	<p> testo </p>

@endsection

````

#### JS e CSS
I file di JS e Css inseriti nella cartella /resources/... verranno compilati e traferiti nella cartella public. 
Per saltare questo step è possibile inserire script e file css direttamente in public/...
Nelle views è possibile linkare direttamnte con: 
````html
<link rel="stylesheet" href="/css.css">
````

#### Dati da controller a views (compact)
Dal controller si richiama la views passando i parametri secondo la seguente sintassi:
````php
$testo = "Qualsiasi testo da passare alla view";
$testo2 = "Altro testo da passare";
return view('home',compact('testo','testo2'));
````
Nella view si inserisce un segnaposto secondo la sintassi:
````html
<p>{{$testo}}</p>
<h1>{{$testo2}}</h1>
````
In alternativa è possibile passare dati a views tramite la funzione With.

## Model e Migration
Prima di creare una Migration bisogna creare un Model che si interfacci con il database.
Si possono creare contemporaneamente Model e Migration con
````bash
php artisan make:model Utente -m
````
 Nota: quando crea un Model, Laravel aggiunge una s a fine nome per indicare in automatico il nome della tabella che dovrebbe essere al plurale.
 Per specificare il nome della tabella basterà specificarlo come nell'esempio:
 ````php
class Utente extends Model
{
    use HasFactory;
    protected $table = 'utenti';
}
````
 
 Per effettuare migrazione e creare table:
 ````bash
php artisan migrate
````
Per resettare tutte le table (chiama metodo down):
 ````bash
php artisan migrate:reset
````

### Eloquent
Specifica chiave primaria:
 ````php
 protected $primaryKey = 'flight_id';
````
Eloquent assume che la chiave primaria sia auto increment. In caso contrario bisogna disattivare l'auto increment:
 ````php
public $incrementing = false;
````
Eloquent assume che la chiave primaria si di tipo integer. In caso contrario bisogna specificare il tipo:
 ````php
protected $keyType = 'string';	
````
Eloquent assume che siano presenti le colonne created_at e updated_at e le gestisce in automatico. In caso contrario specificare:
 ````php
public $timestamps = false;
````
Cambiare nome delle colonne che gestiscono i timestamps created_at e updated_at:
 ````php    
const CREATED_AT = 'creation_date';
const UPDATED_AT = 'updated_date';
````
Cambiare tipo delle colonne che gestiscono i timestamps created_at e updated_at:
 ````php    
protected $dateFormat = 'U';
````
Settare valori di default per alcuni attributi:
 ````php    
protected $attributes = [
	'delayed' => false,
];
````

Interrogazione semplice:
 ````php
 //The Eloquent all method will return all of the results in the model's table.
foreach (Flight::all() as $flight) {
    echo $flight->name;
}
````

Interrogazione condizionata: visita [Query Builder](https://laravel.com/docs/8.x/queries)

## Factory
Permette di generare dati di test da inserire nelle table create da migration. 
Si usa [Faker](https://github.com/fzaninotto/Faker) come libreria php per generare dati falsi.
Per creare Factory:
 ````bash
 php artisan make:factory UtenteFactory --model=Utente
````
Da laravel 8 è necessario aggiungere all'interno del file  di Factory:
````php
use Illuminate\Support\Str;
````
 e cambiare il percoso del Model come da esempio:
````php
    //Da laravel 8 cambiare da
	//protected $model = Utente::class; A:
    protected $model = \App\Models\Utente::class;
````

## Validazione
https://laravel.com/docs/8.x/validation

Per cambiare i messaggi di errore: resources/lang/en/validation.php


## Funzioni utili
`abort(404)` -> Abort e restituisce errore 404
`ddd(testo)` ->Die and Dump: Errore e mostra testo (usare solo in debug)
`return redirect('/homepage')` -> Reindirizza alla homepage




## Da studiare:
https://laravel.com/docs/8.x/csrf





